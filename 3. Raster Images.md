#! https://zhuanlan.zhihu.com/p/351140758
笔记仓库

https://github.com/wzxshhz123/Fundamentals-of-CG-4th-Chinese-Notes

- 大多数计算机图形图像通过某种光栅显像设备呈献给用户. 光栅显像设备将图像显示为矩形像素阵列. 每个像素都有 **RGB** 三个发光点, 通过混合不同强度的三种颜色光像素可呈现不同颜色
  - 所以只要是 "**通过格子(Grid)构成的图像**" 的设备都是光栅设备, 包括大多数打印机如激光打印机与喷墨打印机——通过在网格指定点上喷墨来打印图像
    
    > 打印机的颜色更丰富, 至少是四种颜色的混合
  - 图像输入设备如数码相机, 扫描仪等也是通过栅格的方式记录落在某点处光的颜色和强度从而实现图像输入
- 当这里通过格子(Grid)构成的图像也就是光栅图像了, 由于光栅设备很常见, 光栅图像也成为了存储和处理图像最常用的方式
  - 每个格子称为像素(Pixel, 即 picture element)
  - 光栅图像是一个二维数组, 其存储了每个像素的像素值, 如 RGB
  
- 在实际思考时，使用以下的思考方式从而打破图像像素与显示像素的直接联系——视光栅图像为与显示设备无关的描述, 而显示设备是一种逼近理想图像的方式
- 也有其他描述图像的方式——矢量图(Vector image), 通过存储对形状的描述来描述图像
  - 矢量图本质上**存储了渲染(Render) 图像的指令而没有存储图像原始的像素**, 故**矢量图与分辨率无关, 可不失真显示**
    - 比如存储了一大堆绘制直线的指令 
  - 相应的缺点为矢量图在显示前必须进行光栅化——即根据指令渲染(Render) 光栅图像
  - 矢量图常用于文本, 图表等应用, 在这些应用其中清晰度与精度更被关注(e.g PDF)

本章讨论栅格图像和显示的基础知识, 特别注意**标准显示器的非线性性质**. 同时了解光照强度和像素值的关系

## **3.1 Raster Devices 光栅设备**

- 常见光栅设备
  - 输出
    - 显示
      - Transmissive: LCD 液晶显示器
      - Emissive: LED 发光二极管显示器
    - 硬拷贝
      - Binary: 喷墨打印机
  - 输入
    - 2D array sensor: 数码相机
    - 1D array sensor: 扫描仪

### **3.1.1 Displays 显示设备**

- 目前大多数显示设备都基于固定的像素阵列. 这些设备可被分为发射型显示设备(如 LED)和透射型显示设备(如 LCD)
  - 发射型显示设备可直接发射可控光量的像素, 透射型显示设备中像素本身不发光但可改变通过像素的光量
  - 由于透射型显示设备的原理, 需要一个整体的光源通过设备从而成像
    - 在大多数设备中, 这个工作交给了阵列后的背光;投影仪则靠内部的灯泡
    - 而发射型显示器每个像素处都有自身的小光源
- LED 作为典型的发射型显示设备, 其每个像素处各自都为一个或多个 LED 灯
  - 灯的发光强度取决于通过它们的电流强度
  - 而每个像素被分成独立控制的三个子元素——RGB 三种颜色子像素, 每个像素拥有自己的 LED
    - 观察时人眼无法分辨该三种颜色, 故三种颜色混合在了一起构造出了不同的颜色(如下图所示, 每个像素其实是三个不同颜色的发光二极管小灯组成的)
  
    <center>
    <img src="https://cdn.jsdelivr.net/gh/wzxshhz123/img_md/20210121171222.png" style="zoom:60%">
    </center>

- LCD 液晶显示器作为典型的透射型显示设备, 其材料液晶可旋转通过液晶的光的偏振从而对光进行控制, 而旋转程度可使用电压进行控制
  - 同 LED 一样, 每个像素都有 RGB 三个子像素, 这里通过三个滤色器从而控制对应颜色通过
  - 同时 **LCD 显示器的光源其实也可以是 LED 发光二极管**, 但还是基于液晶的原理进行成像控制
- 对应使用固定像素网格的设备都有分辨率，$rows \times cols$ 可得出该设备拥有的像素数
  
  - 图像分辨率与设备分辨率不一致时必须使用第 9 章的方法进行转换

### **3.1.2 Hardcopy Devices 硬拷贝设备**

- 打印机作为一种光栅设备, 通过在栅格上不同点的位置放置不同颜料从而反射不同颜色的光线从而成像, 而**有些打印机只能打印二进制图像，即打印机只能决定某点处放置或不放置颜料，无中间项**
  - 喷墨打印机作为典型的光栅化打印设备，使用多个打印头进行逐行扫描，每个打印头控制一种颜色，在各自需要喷墨的点处进行喷墨，从而形成二进制图像
    - 喷墨打印机没有使用像素阵列，故分辨率取决于每次扫描时的液滴大小和纸张的前进距离
  - 另一个例子为使用热染料传递的打印机(贴画打印使用的打印机)，不同于喷墨打印机，其可以决定每种颜色的染料在某点处的多少。其使用热加热的方式将色带上的颜色留在纸上，而染料沉积的多少由温度进行确定
    - 其分辨率由加热元件多少与加热与冷却速率之比确定
- 对于打印机来说，分辨率由像素密度决定而不是和显示设备一样由像素数量决定。故对打印机像素的描述为 **ppi** —— 每英寸的像素数
  - **ppi 与 dpi 都表示每英寸的像素数，但 ppi 用于描述连续的设备如热染料传递的打印机， dpi 用于描述数字设备如显示器**
    - 如 Apple 关于 Retina 屏幕的定义, 根据不同尺寸给出了对 DPI 的要求
  - 喷墨打印机也是数字设备，其需要高分辨率来抗锯齿与描述中间色
  
### **3.1.3 Input Devices 输入设备**

- 光栅图像常使用数码相机等设备进行输入. 而图片也会用作 3D 场景的贴图。光栅输入设备必须对每个像素上的光进行测量, 使用的是光学传感器其通常基于光传感器阵列
  - 比如现在手机常使用索尼大法的 CMOS
- 数码相机作为典型的光栅输入设备，其光传感器成栅格状排列，常见的两种传感器类型为 CCD 和 CMOS。相机将所拍摄场景的图片通过小孔成像投影到传感器上，传感器测量记录落在每个栅格点处的光的信息，最终生成数字图像。而数码相机使用滤光片阵列使得测量出的每个像素值只有 RGB 三种颜色
  - 扫描仪使用一维方式逐行进行 RGB 的扫描。**扫描出的分辨率由阵列的固定大小与测量频率与扫描头移动速度之比决定**。每秒进行多次扫描
    - 对于扫描仪来说，像素的 RGB 值单独存储，构成一个 $3*n_x$ 的数组存储。其中 $n_x$ 为页面上的像素总数。扫描仪可以在每点进行单独的三次颜色取值，使用 **ppi** 进行扫描仪像素的表示
    - 一般扫描仪得到的文档分辨率可以进行任意转换而不失真

## **3.2 Images, Pixels, and Geometry**

- 在二维世界中，图像是一个在二维区域上定义的函数
  $$
  I(x,y):R \rightarrow V
  $$
  $R \subset R^2$ 是一个矩形区域而 $V$ 是像素所有可取的值的集合(色域)
  - 对于图像来说，最简单的形式为灰度图像（黑白图像）, 每个点都只是一个亮度. 此时我们可以说 $V=R^+$ （非负实数）
  - 而对于彩色图像, $V={(R^+)}^3$
- 光栅图像为离散的, 而实际图像为连续的. 故在**光栅图像中每个像素取得是周围区域的平均颜色**; 而对于显示设备, 其通过控制每个像素的 RGB 三种子像素从而使得图像的平均颜色通过每个像素的像素值进行控制
  - 综上我们可以看出, **像素值实质为该点所在方格颜色的平均值**

  - 当我们谈论一个像素的值为 $x$ 时, 这意味着“该格子点附近区域的值为 $x$

    <img src="https://cdn.jsdelivr.net/gh/wzxshhz123/img_md/20210217221356.png" alt="image-20210217221356583" style="zoom:50%;" />
- 本书中使用上图的坐标表示像素, 原点在左下角. 每个像素的采样点都为整数坐标
  - 对于一个拥有 $n*n$ 个采样点的矩形, 其图像的定义域表示为 $$R=[-0.5,n_x+0.5]*[-0.5,n_y+0.5]$$ , 即**最右上方顶点坐标为在第 $n$ 个点位置基础上朝 $x、y$ 方向分别延长半个像素**
  - 这里只是书中定义的一种坐标, 实际情况下坐标位置不一

### 3.2.1 Pixel Values 像素值

- 图像是一个浮点型数组，理论上每个像素应该存储一个（灰度图像）或三个（RGB 图像）$32$ 位的浮点型数
  - 但**若直接使用 $32$ 位浮点数时**，一个 RGB 颜色空间的像素占用 $96$ 位，即12B，**一张 $1080P$ 图像由 $1920*1080=2073600$ 个像素构成,占用 $2073600*12=23MB$，占用大量的存储空间**
  - 同时由于人眼可感知的色彩空间并没有这么多, 故我们**通常每个通道使用 $8$ 位来进行表示**, **同时限制像素范围为 **$[0,1]$
    - 既节省了存储空间，又基本满足了人眼需求。
    - 如对于 8 位颜色深度的图像来说, 其像素值为$0,\frac1 {255},\frac2 {255}...\frac{254}{255},1$
  - **图像使用浮点数存储并允许使用大范围的值时该图像 通常被称为高动态范围(HDR)图像，以将它们与固定范围或低动态范围(LDR)图像区分开来**
  
- 目前具有代表性的一些像素范围

  - 注意这里的两种 HDR 图像, HDR 图像格式其实很多, 建议使用 https://github.com/Tom94/tev 该查看器进行查看

  <img src="https://cdn.jsdelivr.net/gh/wzxshhz123/img_md/20210217221952.png" alt="image-20210217221952640" style="zoom:35%;" />

  

- **当表示颜色深度的位数减少时会使得超过当前颜色值的颜色被强行降下来; 同时当需要对像素值进行舍入等操作时会使得图像产生条带，在动画或视频中条带非常明显, 影响视觉效果**

  - 所以对于现在比较高级的 HDR 显示器来说, 最大的功能是不会出现这种稍微亮点的地方一片亮啥也看不清, 稍微黑点的地方一片黑啥也看不清的情况

### 3.2.2 Monitor Intensities and Gamma 显示器亮度与γ值

- 目前的显示器都输入数字信号并将其转化为亮度值

  - 断电后的显示器亮度不为 $0$, 因为其仍会反射环境光, 但我们近似认为其为“黑色”
  - 显示器完全打开时呈“白色”. 
  - 对像素颜色使用 $[0,1]$ 表示时, **$0$ 为黑色, $1$ 为白色,介于黑白的中间灰色为 **$0.5$
    - 此处的强度为像素发出光线的强度而非观察到的亮度

- 显示器对输入信号的处理为非线性的
	
	- **所以电压输入强度为 0.5, 其实真正显式输出的亮度小于 0.5**
	- 为了表示上面这种非线性关系, 常通过 $γ$ 值来近似其非线性系数, $M$ 为最大亮度
  
  $$
  显示亮度=\alpha^γ * M
  $$
  **其中 $\alpha$ 为介于 $0$ 到 $1$ 之间的输入的亮度值, 即自变量. 不同的屏幕 $γ$ 值不同**
  
- 为了获得不同屏幕的 $γ$ 的近似值, 可找到一个 $a$, **这个 $a$ 非线性变化后的显示强度为 0.5**
  $$
  0.5 = a^{\gamma} * M
  $$
  **之后直接取对数得到近似非线性系数**
  $$
  γ=\frac{ln0.5}{lna}
  $$
  其中 $a$ 的确定可通过观察下面的图像, **调整右边的亮度使得在远处观察时右边亮度近似于左边, 则右边强度为 0.5 强度的 $a$, 将此时的 $a$ 值代入上式即可得到 $γ$ 值**

  <img src="https://cdn.jsdelivr.net/gh/wzxshhz123/img_md/20210217234004.png" alt="image-20210217234004780" style="zoom:50%;" />
  
- 因为该问题的存在, **所以常常在输出图像前需要进行一个补偿来抵消这个颜色强度降低的变化, 即伽马校正**

  - 将输入值变为输入值的 $\large\frac{1}{γ}$ 次方, 即输入亮度进行变化
  	$$
  	\alpha^{\frac1 γ}
  	$$
  	代入亮度计算公式即可抵消掉非线性系数
  	$$
  	显示亮度=\alpha * M
  	$$
  	**在不知道具体的 $\gamma$ 的情况下, 一般用 2.2 默认值**

- 虽然这里我们讨论的亮度是在浮点范围 $[0,1]$ 内的一个值
  
  - 但在常见的颜色深度为 $8$ 位 的情况下, 输入其实是 $[0, 255]$ 的非负整数, 此时 $\alpha$ 的取值为
$$
\alpha=\{\frac0 {255},\frac1 {255},\frac2 {255}...\frac{255} {255}\}
$$


  - 这意味着屏幕的亮度近似值为需要对这些分数上幂运算, 
    $$
    \left\{M\left(\frac{0}{255}\right)^{\gamma}, M\left(\frac{1}{255}\right)^{\gamma}, M\left(\frac{2}{255}\right)^{\gamma}, \ldots, M\left(\frac{254}{255}\right)^{\gamma}, M\left(\frac{255}{255}\right)^{\gamma}\right\}
    $$


      - 在该情况下, 将亮度分为了 $256$ 个亮度等级
## **3.3 RGB Color** RGB 颜色

- 多数显示效果都由 RGB 色彩空间决定, 该色彩空间基本思想是控制三种基色光 红、绿、蓝 的强度变化并将其进行混合从而得到其他所有的颜色

  - 一般讨论的 RGB 空间有微软的 sRGB 和 Adobe 的 Adobe RGB, 二者色域大小有差别

  - **基色光单色最暗时值为 $0$ 最亮时值为 $1$。则可产生一种三维 RGB 颜色的立方体，红绿蓝作为坐标轴**  

    <img src="https://cdn.jsdelivr.net/gh/wzxshhz123/img_md/20210217222337.png" alt="image-20210217222337638" style="zoom:50%;" />

    立方体八个顶点坐标分别代表了不同的颜色

    <img src="https://cdn.jsdelivr.net/gh/wzxshhz123/img_md/20210217223813.png" alt="image-20210217223813124" style="zoom:50%;" />

    <img src="https://cdn.jsdelivr.net/gh/wzxshhz123/img_md/20210217223826.png" alt="image-20210217223826606" style="zoom:50%;" />

  - 在实际使用时, 由于 RGB 三种成分都用一个字节 8 位整数进行表示, 所以也常常用 8 位整数所能描述的范围 $[0, 255]$ 来表示各个分量

    - 三个整数共占用三个字节 $24$ 位, 每种颜色有 $256$ 个等级
    - 讨论的伽马校正的问题也可以同时作用于 RGB 的三个分量
## **3.4 Alpha Compositing $\alpha$ 混合**

- 对于一张图像，我们常常会出现只想覆盖其部分像素的情况. 典型的例子为将两张图像进行合成, 一张作为前景, 另外一张作为背景色。
  - **此时我们通过一个分数 $\alpha$ 来表示前景色所覆盖的像素部分, 其实就是前后景两个颜色在每个像素上做线性插值**
    
    - 即如果想把前景色 $c_f$ 和背景色 $c_b$ 混合，那么最终的混合结果 
    	$$
    	c=\alpha c_f+(1-\alpha )c_b
    	$$
      
    - 当前景层不透明时, 该式表示前景颜色覆盖区域的 $\alpha$ 部分, 背景色覆盖区域剩余的部分 $(1-\alpha )$
    
  - 当前景层有半透明像素（如玻璃类似的半透明部分）时, 该式表示前景色会移除背景色的$(1-\alpha)$ 的部分, 同时使用自己颜色的 $\alpha$ 部分来代替被移除的部分
- **图像中所有像素的 $\alpha$ 值可以存储在单独的灰度图像中，该灰度图像被称为 $\alpha$ 蒙版**
    - 除此之外也可以将 $\alpha$ 的值作为像素的另一种信息与 RGB 一起保存起来, 此时的图像为  RGBA 图像, 每个像素不只占据 $24$ 位, 而是占据 $32$ 位

    - 我们将存储 $\alpha$ 值的部分称之为 $\alpha$ 通道

    - **默认情况下背景色为白色, 所以调整 $\alpha$ 通道值可以使得当前颜色和白色线性混合从而达到透明度的效果**

        - $\alpha$ 为 0, 全部是背景白色物体完全消失

        <img src="https://cdn.jsdelivr.net/gh/wzxshhz123/img_md/20210217234806.png" alt="image-20210217234806035" style="zoom:40%;" />

### 3.4.1 Image Storage 

- **为了保存高分辨率的 RGB 图像(哪怕只是 8 位也太大), 存储时多进行压缩**. 
  - **压缩分为有损压缩与无损压缩**
    - 有损压缩会丢失部分图像信息并不可恢复	
    - 无损压缩信息不会丢失
- 常见的图像格式
  - **jpeg** 有损压缩
  - **TIFF** 无损压缩, 常保存二进制图像
  - **ppm**  为最简单的无损未压缩格式, 根据存储的是 RGB 还是灰度图有自己的格式, 比较好读写
  - **png**  也是常用的无损压缩格式
- **对图像进行输入输出时由于涉及到压缩和解压缩,  一般直接使用一些现有 lib** 
  - 比如 header-only 的知名图像库 https://github.com/nothings/stb, 支持多种图像格式
- 那若不使用库，则输出指定文件格式的图像比较困难. **此时我们可以直接输出为原始的 $ppm$ 格式, 该格式便是直接将存储图像的数组转存到文件中**

## Frequently Asked Questions

- 为什么显示器不做成线性的从而避免伽马校正?
  - 人的光感知系统为非线性, 故我们需要一个 $[1.5,3]$ 范围内的 $γ$ 值(根据显示器使用环境) **对人的感知系统进行校正从而使得人感知到的光是均匀的**
  - 而碰巧的是显示器的非线性显式和人的非线性感知基本吻合, 所以不如做成非线性让用户可以自己调整 $\alpha$ 来适配自己的需求