**"计算机图形" 是一门研究, 使用计算机创建和处理图形图像的学科.** 

本书介绍了可用于创建各种图像的算法和数学工具, 特别是用于生成三维物体和场景的合成图像的算法.

- 图形既可以是二维图形, 也可以是三维图形.
- 图像可以是完全合成的, 也可以通过其它图像处理得到.

## **1.1 Graphics Areas**

CG 的三大核心领域:

- **建模** (Modeling)
  - 以计算机的方式来描述 Shape 的数学几何属性以及外观属性. (如常见的 TriangleMesh, 将一个 Shape 表示为一系列三角形的集合)
- **渲染** (Rendering)
  - 通过 3D Model 生成图像
- **动画** (Animation)
  - 引入时间因素, 通过一系列图像来让人感觉到 "运动"

除此之外还有些用到 CG 技术的领域, 至于它们是否为图形的核心领域还有待商榷

- **人机交互 (User interaction)**
- **虚拟现实 (Virtual reality)**
- **可视化 (Visualization)**
- **图像处理 (Image processing)**
- **3D 扫描 (3D scanning)**
- **计算摄影学 (Computational photography)**

## **1.2 Major Applications**

- **游戏 (Video games)**
- **卡通 (Cartoons)**
  - 这里的卡通应该是偏向于 3D 渲染出 2D 的技术(俗称 3 渲 2, 与动画电影做了区分
- **视觉特效 (Visual effects)**
- **动画电影 (Animated films)**
- **计算机辅助设计与计算机辅助制造 (computer aided design / computer aided manufacturing，CAD/CAM)**
- **模拟 (Simulation)**
  - 不同于物理上要求精度特别高的模拟, CG 的模拟应该更偏向于 "看上去是真的, 那就是真的". 当然这还是需要很多的物理知识做支撑
- **医学成像 (Medical imaging)**
- **信息可视化 (Computed tomography)**

## **1.3 Graphics API**

使用图形 lib 的关键之一是使用 图形 API. API 是执行一组相关操作的标准功能集合, 而图形 API 是执行诸如将图像和 3D Surface 绘制到屏幕上的窗口之类的基本操作的一组功能.

一般来说, **一个图形程序需要两套 API — 一套用于显示输出, 另一套用于用户交互**

- 有的语言将上述两套 API 进行了集成(如 Java)
- 而如果使用 Direct3D, OpenGL, Vulkan 等可以直接和 GPU 打交道的 API, 需要视情况引入窗口库
  - 如基于 OpenGL 进行编程常需要搭配 glut, freeglut, glfw 等窗口库进行使用
    - 同时由于 OpenGL 的跨平台特性, 需要使用 glew 等 API 使得代码做到与平台无关

## **1.4 Graphics Pipeline**

目前所有的计算机都有非常强大的 3D Graphics Pipeline, 这是一种特别的软硬件结合的子系统. 其为使用共享顶点三角形的 3D 图元进行过优化，可以非常高效地绘制 3D primitive

- 图形管线的基本操作就是把 3D 顶点的位置映射到 2D 屏幕上并为三角形图元着色以便其看上去栩栩如生
- 过去渲染有前后层次的三角形一直是一个大问题, 但现在这个问题一般都通过使用 z-buffer 来实现,  z-buffer 缓冲器使用额外的缓冲区以一种粗暴的方法解决了该问题
- 图形管线中使用的所有几何操作几乎都可以在由空间坐标 $(x, y, z)$ 和第四维齐次坐标组成的四维坐标空间中完成, 第四维坐标用于处理透视问题
  - 4 维坐标系使用 4 * 4 矩阵与四维向量
- 渲染速度很大程度上取决于模型的三角形数的多少. 因为在大多数图形系统中交互远比图形质量更为重要, 所以为了提高绘制速度可以适当减少三角形数. 
  - 为了节省资源, 同一个模型在较远时的三角形数量和较近时的三角形数量可以不一样. 这种表示方法称作 **level of detail (LOD)**

## **1.5 Numerical Issues**

许多图形程序实际上就是 3D 数值代码, 数值问题是非常重要的问题

- 目前大部分电脑使用 IEEE 浮点表示法, 使得对数值的处理鲁棒了起来
- IEEE 浮点表示法对于图形学最重要的几点：
  - 三个特殊的实数值
    1. 正无穷 $+\infty$ 比任何数都要大的数
    2. 负无穷 $-\infty$ 比任何数都要小的数
    3. 无效数 ($\textbf{NaN}$, Not a Number)无意义的数
  - 相关基本运算
    1. $+a / (+\infty) = +0$
    2. $−a / (+\infty) = −0$
    3. $+a / (−\infty) = −0$
    4. $−a / (−\infty) = +0$
    5. $\infty + \infty = +\infty$
    6. $\infty − \infty = \textbf{NaN}$
    7. $\infty \times ∞ = ∞$
    8. $\infty / \infty = \textbf{NaN}$
    9. $\infty / a = \textbf{NaN}$
    10. $\infty / 0 = \infty$
    11. $0 / 0 = \textbf{NaN}$
  - 基本规则
    1. **所有有限有效数字都小于正无穷**
    2. **所有有限有效数字都大于负无穷**
    3. **正无穷大于负无穷**
    4. **所有带有 $\textbf{NaN}$ 的式子结果为 $\textbf{NaN}$**
    5. **所有带有 $\textbf{NaN}$ 的布尔判断结果都为 false**
  - IEEE 浮点表示法最大的作用可能为解决了除数为 0 的问题. 对于任意正实数 a
       1. $+a / +0 = +\infty$
       2. $−a / +0 = −\infty$
 
- **如果程序员利用 IEEE 规则, 则许多数值计算会变得更加简单**
  - 如下式中, 涉及到三个可能的除以 0 的操作
  $$
      a = \frac{1}{\frac{1}{b} + \frac{1}{c}}
  $$
    一般来说我们需要对两次除以 0 的操作(b == 0?, c == 0?)都进行判断, 但因为 IEEE 浮点数规则的存在, 当 b 或 c 为 0 时我们可以很自然得到 $a = 0$(基本计算规则 1.)
  - 除此之外**通过通过 $\textbf{NaN}$ 的布尔属性, 可以省去很多额外的检查**
    - 比如以下的代码在 $a = \textbf{NaN}$ 时照样可以正常运作 
  ```c++
    a = f(x)
    if (a > 0) then do something
  ```

## **1.6 Efficiency**

- 为了程序效率, 一个好的方法是编程时应该更关注内存访问模式而不是操作计数
  - 由于内存的速度跟不上处理器的速度, 即 IO 成为了瓶颈, 所以我们更应该关注内存访问方式来减少 IO
- 一个合理编程方法的步骤：
  1. 以最直接的方式编写代码. 根据需要计算中间结果而不提前把不是提前将他们存起来
  2. 以最优化的方式进行编译(-O3)
  3. 使用分析工具分析可能存在的性能瓶颈
  4. 测试数据结构来找到可以提高性能的位置. 如果可能的话, 将数据单元大小匹配到目标架构的缓存或者页大小, 从而减少换页操作
  5. 如果分析工具显现出瓶颈在数值计算处, 检查汇编代码是否存在瓶颈并重构代码解决问题
- **上述步骤中最关键的点为第一点**. 大多数的 "优化" 都会降低代码的可读性而并不能增加速度.
  - **前期优化代码所花费的时间通常会更好地用于纠正错误或增加功能**
- 一些老的优化技巧如**使用整数而不是实数类型已经不会增加速度**
  - 现代 CPU 计算浮点数与计算浮点数速度一样快
- 在所有的情况下, 分析代码时需要考虑到对特定架构, 编译器的优化

## **1.7 Designing and Coding Graphics Programs**

### 1.7.1 Class Design

- 图形学编程的基本部分为 vector class, matrix class
- vector, point 是否应该分为不同的类是一个大的争论
  - 比如位置乘以 1/2 没有几何意义, 而位移有
  故本书对这两个概念不作区分
  - 批注中作者认为应该分为两个类从而易于暴露一些 bugs
    - 同时考虑到分开写两个类的话从数学切换到 code 更容易一些
- 基本的类
  1. vector2 包括 x,y 信息 应该存储在一个长度为2的数组中。同时实现点积、叉积等操作
  2. vector3 包括 x,y,z 特性同 vector2
  3. hvector 具有四个分量的均匀分量
  4. rgb 存储对于RGB的数据，并实现相乘等操作
  5. transform 一个用来变换的 4 * 4 方阵。包括矩阵相乘、位置变换、方向变换等操作
  6. image 具有输出功能的存储 RGB 像素的二维数组
   
  > 另外，还可以有表示规范正交基、坐标系、单位向量等的类

### 1.7.2 Float vs. Double

- 为了连续读写内存, 使用单精度的 float 速度更快.
  但 float 可能会带来一些数值计算上的问题.
  > 建议使用其中一位作者的原则来简化问题: 正常情况下使用 float, 当用 float 无法解决问题时使用 double 

### 1.7.3 Debugging Graphics Programs

- 使用单步调试有些时候成本太高, 我们需要更效率的调试方式
- 以下是几种调试思想:

#### **The Scientific Method**

- 创建图形, 查找错误. 然后, 假设是什么造成了这个错误并将其取消, 重新编译, 观察问题是否解决从而缩小错误范围
  - 比如假设是阴影渲染导致的问题, 那就注释掉阴影渲染的代码看问题有没有解决
 
#### **Images as Coded Debugging Output**

- 直接为指定位置进行着色等操作观察结果
  - 如发生预料之外的情况时该部分像素涂上红色等
  - 或者将一些量通过该方法进行 RGB 映射从而可视化成 image 输出

#### **Using a Debugger**

- 使用单步调试图形程序及其困难. 但是当前两种方法无法清晰的展现 bug 时，可以采用单步调试:
  - 注意关闭多线程
  - 固定随机种子
  - 添加条件判断锁定错误和发生问题的位置
  - 灵活使用 assert() 断言
  - 如果程序直接崩溃了, 调试器也可以锁定到崩溃位置

#### **Data Visualization for Debugging**

- 可以将所有调试信息进行可视化输出进行调试.
  - 如光线追踪时可以编写将所有光线树进行展现的代码, 以便发现哪些光线树读像素生成有贡献
    - 同时这些可视化代码在优化时也能帮助我们理解程序

     > 作者批注：他喜欢将所有的调试信息输出成 MATLAB 或 Gnuplot 格式的脚本以便生成有帮助的插图